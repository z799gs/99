<?xml version="1.0" encoding="UTF-8" ?>
<Module>
<ModulePrefs title="-" />
<Content type="html"><![CDATA[


<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/z799gs/99@main/TemplateData/style.css"/>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }

      body {
        background: #0a0a1a;
        overflow: hidden;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }

      #unity-container {
        position: relative;
        width: 100%;
        height: 100vh;
      }

      #unity-canvas {
        width: 100%;
        height: 100%;
        background: #0a0a1a;
      }

      /* ==================== LOADING SCREEN ==================== */
      #custom-loading {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3e 50%, #0a1628 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
        transition: opacity 0.8s ease;
      }

      #custom-loading.fade-out {
        opacity: 0;
        pointer-events: none;
      }

      .loading-icon {
        font-size: 56px;
        margin-bottom: 20px;
        animation: pulse 1.5s ease-in-out infinite;
      }

      @keyframes pulse {
        0%, 100% { transform: scale(1); opacity: 1; }
        50% { transform: scale(1.15); opacity: 0.8; }
      }

      .loading-title {
        font-size: 36px;
        font-weight: 900;
        color: #00d4ff;
        text-shadow: 0 0 20px rgba(0, 212, 255, 0.4), 0 4px 8px rgba(0,0,0,0.5);
        margin-bottom: 8px;
        letter-spacing: 4px;
      }

      .loading-subtitle {
        font-size: 13px;
        color: #6080a0;
        margin-bottom: 35px;
        letter-spacing: 1px;
      }

      .progress-container {
        width: 380px;
        margin-bottom: 12px;
      }

      .progress-bar-bg {
        width: 100%;
        height: 20px;
        background: rgba(255,255,255,0.08);
        border-radius: 10px;
        overflow: hidden;
        border: 1px solid rgba(0, 212, 255, 0.2);
      }

      .progress-bar-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, #0066ff, #00d4ff, #0066ff);
        background-size: 200% 100%;
        border-radius: 10px;
        transition: width 0.3s ease;
        animation: shimmer 1.5s linear infinite;
      }

      @keyframes shimmer {
        0% { background-position: 200% 0; }
        100% { background-position: -200% 0; }
      }

      .progress-text {
        color: #00d4ff;
        font-size: 15px;
        font-weight: bold;
        text-align: center;
        margin-top: 8px;
      }

      .loading-status {
        color: #5a7a9a;
        font-size: 12px;
        margin-top: 4px;
        text-align: center;
        min-height: 18px;
      }

      .fun-message {
        color: #8090b0;
        font-size: 13px;
        margin-top: 25px;
        font-style: italic;
        opacity: 0.7;
        text-align: center;
        min-height: 20px;
        transition: opacity 0.3s ease;
      }
    </style>
  </head>
  <body class="dark">
    <div id="unity-container" class="unity-desktop">
      <canvas id="unity-canvas"></canvas>

      <!-- CUSTOM LOADING SCREEN -->
      <div id="custom-loading">
        <div class="loading-icon">G+</div>
        <div class="loading-title">LOADING</div>
        <div class="loading-subtitle">Preparing game assets...</div>
        <div class="progress-container">
          <div class="progress-bar-bg">
            <div class="progress-bar-fill" id="merge-progress-bar"></div>
          </div>
          <div class="progress-text" id="merge-progress-text">0%</div>
          <div class="loading-status" id="merge-status">Initializing... Xd?</div>
        </div>
        <div class="fun-message" id="fun-message"></div>
      </div>
    </div>

    <script>
      // ==========================================
      // FUN LOADING MESSAGES
      // ==========================================
      const funMessages = [
        "Loading textures and shaders... ðŸŽ¨",
        "Building the world around you... ðŸŒ",
        "Placing all the objects... ðŸ“¦",
        "Waking up the NPCs... ðŸ§‘",
        "Polishing the graphics... âœ¨",
        "Tuning the physics engine... âš™ï¸",
        "Syncing game logic... ðŸ§ ",
        "Almost there, hang tight... ðŸš€",
        "Final touches in progress... ðŸŽ¯",
        "Get ready to play! ðŸ†"
      ];

      let funMsgIndex = 0;
      const funMsgEl = document.getElementById('fun-message');

      function rotateFunMessage() {
        funMsgEl.style.opacity = '0';
        setTimeout(() => {
          funMsgEl.textContent = funMessages[funMsgIndex % funMessages.length];
          funMsgEl.style.opacity = '0.7';
          funMsgIndex++;
        }, 300);
      }

      rotateFunMessage();
      const funMsgInterval = setInterval(rotateFunMessage, 3000);

      // ==========================================
      // FILE MERGE SYSTEM
      // ==========================================
      const mergeConfig = {
        files: [
          { name: 'game.data.br', parts: 4 },
          { name: 'game.wasm.br', parts: 4 }
        ],
        basePath: 'https://cdn.jsdelivr.net/gh/z799gs/99@main/Build/'
      };

      const mergedFiles = {};
      const progressBar = document.getElementById('merge-progress-bar');
      const progressText = document.getElementById('merge-progress-text');
      const statusEl = document.getElementById('merge-status');

      async function mergeFileParts(baseName, partCount, progressCallback) {
        const chunks = [];
        for (let i = 0; i < partCount; i++) {
          const partUrl = mergeConfig.basePath + baseName + '.part' + i;
          const response = await fetch(partUrl);
          if (!response.ok) throw new Error(`Failed to load ${partUrl}: ${response.status}`);

          const reader = response.body.getReader();
          const partChunks = [];
          let received = 0;

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            partChunks.push(value);
            received += value.length;
          }

          const partData = new Uint8Array(received);
          let offset = 0;
          for (const chunk of partChunks) {
            partData.set(chunk, offset);
            offset += chunk.length;
          }

          chunks.push(partData);
          progressCallback(i + 1, partCount);
          console.log(`[MERGE] ${baseName} part${i} loaded (${(received / 1024 / 1024).toFixed(2)} MB)`);
        }

        const totalSize = chunks.reduce((acc, c) => acc + c.length, 0);
        const merged = new Uint8Array(totalSize);
        let off = 0;
        for (const chunk of chunks) {
          merged.set(chunk, off);
          off += chunk.length;
        }

        console.log(`[MERGE] ${baseName} merged (${(totalSize / 1024 / 1024).toFixed(2)} MB)`);
        return merged.buffer;
      }

      async function mergeAllFiles() {
        const totalParts = mergeConfig.files.reduce((a, f) => a + f.parts, 0);
        let completedParts = 0;

        for (const file of mergeConfig.files) {
          statusEl.textContent = `Downloading ${file.name}...`;

          const buffer = await mergeFileParts(file.name, file.parts, (current, total) => {
            completedParts++;
            const pct = Math.round((completedParts / totalParts) * 100);
            progressBar.style.width = pct + '%';
            progressText.textContent = pct + '%';
            statusEl.textContent = `${file.name} â€” part ${current}/${total}`;
          });

          mergedFiles[file.name] = buffer;
        }

        statusEl.textContent = 'Starting game engine...';
        progressBar.style.width = '100%';
        progressText.textContent = '100%';
      }

      // ==========================================
      // FETCH INTERCEPTOR
      // ==========================================
      const originalFetch = window.fetch;
      window.fetch = function(url, options) {
        if (typeof url === 'string') {
          for (const file of mergeConfig.files) {
            if (url.endsWith(file.name) || url.includes('/' + file.name)) {
              if (mergedFiles[file.name]) {
                console.log(`[INTERCEPT] Serving merged: ${file.name}`);
                return Promise.resolve(new Response(mergedFiles[file.name], {
                  status: 200,
                  headers: { 'Content-Type': 'application/octet-stream' }
                }));
              }
            }
          }
        }
        return originalFetch.apply(this, arguments);
      };

      // ==========================================
      // XMLHttpRequest INTERCEPTOR (Unity fallback)
      // ==========================================
      const OrigXHR = XMLHttpRequest;
      window.XMLHttpRequest = function() {
        const xhr = new OrigXHR();
        const origOpen = xhr.open;

        xhr.open = function(method, url) {
          this._url = url;
          return origOpen.apply(this, arguments);
        };

        const origSend = xhr.send;
        xhr.send = function(body) {
          if (this._url && typeof this._url === 'string') {
            for (const file of mergeConfig.files) {
              if (this._url.endsWith(file.name) || this._url.includes('/' + file.name)) {
                if (mergedFiles[file.name]) {
                  console.log(`[XHR-INTERCEPT] Serving merged: ${file.name}`);
                  const self = this;
                  setTimeout(() => {
                    Object.defineProperty(self, 'status', { get: () => 200 });
                    Object.defineProperty(self, 'readyState', { get: () => 4 });
                    Object.defineProperty(self, 'response', { get: () => mergedFiles[file.name] });
                    Object.defineProperty(self, 'responseType', { get: () => 'arraybuffer' });
                    if (self.onload) self.onload();
                    if (self.onreadystatechange) self.onreadystatechange();
                  }, 0);
                  return;
                }
              }
            }
          }
          return origSend.apply(this, arguments);
        };

        return xhr;
      };
      window.XMLHttpRequest.prototype = OrigXHR.prototype;
      window.XMLHttpRequest.DONE = 4;
      window.XMLHttpRequest.HEADERS_RECEIVED = 2;
      window.XMLHttpRequest.LOADING = 3;
      window.XMLHttpRequest.OPENED = 1;
      window.XMLHttpRequest.UNSENT = 0;

      // ==========================================
      // UNITY INIT
      // ==========================================
      const container = document.querySelector('#unity-container');
      const canvas = document.querySelector('#unity-canvas');

      const buildUrl = 'https://cdn.jsdelivr.net/gh/z799gs/99@main/Build';
      const loaderUrl = buildUrl + '/loader.js';
      const config = {
        dataUrl: buildUrl + '/game.data.br',
        frameworkUrl: buildUrl + '/game.js',
        codeUrl: buildUrl + '/game.wasm.br',
        streamingAssetsUrl: '',
        companyName: 'GAME',
        productName: 'GAME',
        productVersion: '1.0',
      };

      if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        container.className = 'unity-mobile';
        config.devicePixelRatio = 1;
      }

      // MAIN: Merge first, then load Unity
      mergeAllFiles().then(() => {
        clearInterval(funMsgInterval);

        const script = document.createElement('script');
        script.src = loaderUrl;
        script.onload = function() {
          createUnityInstance(canvas, config, function(progress) {
            const pct = Math.round(progress * 100);
            progressBar.style.width = pct + '%';
            progressText.textContent = pct + '%';
            statusEl.textContent = 'Loading game engine... ' + pct + '%';
          }).then(function(unityInstance) {
            window.unityInstance = unityInstance;
            // Hide loading screen
            document.getElementById('custom-loading').classList.add('fade-out');
            setTimeout(() => {
              document.getElementById('custom-loading').style.display = 'none';
            }, 800);
          }).catch(function(message) {
            console.warn(message);
          });
        };
        document.body.appendChild(script);
      }).catch((err) => {
        statusEl.textContent = 'Error: ' + err.message;
        progressBar.style.background = 'red';
        console.error('[MERGE] Fatal error:', err);
      });
    </script>
    
  <style>
  #ad-container {
    position: fixed;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: min(728px, calc(100% - 20px));
    height: 90px;
    background: rgba(0, 0, 0, 0.90);
    display: none;
    z-index: 99999;
    overflow: hidden;
    box-shadow: 0 -2px 12px rgba(0, 0, 0, 0.45);
    transition: transform 0.5s ease-in-out;
  }

  #ad-container.hidden { transform: translate(-50%, 100%); }

  #ad-iframe {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 745px;
    height: 90px;
    border: 0;
  }

  /* Close button: Initial Top Center */
  #close-ad {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%) scale(0.9);
    transform-origin: center;
    background: #ff4d4d;
    color: #fff;
    border: none;
    padding: 5px 10px;
    font-size: 11px;
    font-weight: bold;
    border-radius: 4px;
    cursor: not-allowed;
    opacity: 0.9;
    z-index: 100000;
    white-space: nowrap;
    transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  }

  /* Corner State Styling */
  #close-ad.enabled {
    cursor: pointer;
    opacity: 1;
    background: #ff1a1a;
    box-shadow: 0 0 15px #ff4d4d, 0 0 30px #ff4d4d;
    animation: glow-pulse 1.5s infinite alternate;
  }

  @keyframes glow-pulse {
    from { box-shadow: 0 0 5px #ff4d4d, 0 0 10px #ff4d4d; }
    to { box-shadow: 0 0 20px #ff4d4d, 0 0 35px #ff4d4d; opacity: 0.8; }
  }

  #close-ad::before {
    content: 'âœ•';
    margin-right: 2px;
  }

  @media (max-width: 440px) {
    #ad-container { width: calc(100% - 12px); }
    #ad-iframe { width: 728px; }
  }
</style>

<div id="ad-container" aria-hidden="true">
  <iframe id="ad-iframe" src="https://script.google.com/macros/s/AKfycbzNG4z_PlG6Ke_bX5wSPKK2uBRB3IY9ouVzqM1shucYhSTvsJWRmyMyZaaC2z5S3ADN/exec" scrolling="no" frameborder="0" sandbox="allow-scripts allow-popups allow-same-origin"></iframe>
  <button id="close-ad" disabled>Wait (12)</button>
</div>

<script>
  (function () {
    const showDelay = 2000; 
    const countdownStart = 12; 
    const reappearDelay = 150000; // 2.5 MINUTES (150 seconds)
    const adContainer = document.getElementById('ad-container');
    const closeBtn = document.getElementById('close-ad');

    function setRandomCorner() {
      const corners = [
        { top: '2px', left: '2px', right: 'auto', bottom: 'auto', transform: 'scale(0.5)' },    // Top-Left
        { top: '2px', left: 'auto', right: '2px', bottom: 'auto', transform: 'scale(0.5)' },   // Top-Right
        { top: 'auto', left: '2px', right: 'auto', bottom: '2px', transform: 'scale(0.5)' },   // Bottom-Left
        { top: 'auto', left: 'auto', right: '2px', bottom: '2px', transform: 'scale(0.5)' }    // Bottom-Right
      ];
      
      const randomChoice = corners[Math.floor(Math.random() * corners.length)];
      Object.assign(closeBtn.style, randomChoice);
    }

    function resetToCenter() {
      closeBtn.style.top = '0';
      closeBtn.style.left = '50%';
      closeBtn.style.right = 'auto';
      closeBtn.style.bottom = 'auto';
      closeBtn.style.transform = 'translateX(-50%) scale(0.9)';
    }

    function showAd() {
      resetToCenter();
      adContainer.style.display = 'block';
      adContainer.classList.remove('hidden');
      
      let timeLeft = countdownStart;
      closeBtn.disabled = true;
      closeBtn.classList.remove('enabled');
      closeBtn.textContent = `Wait (${timeLeft})`;

      const t = setInterval(() => {
        timeLeft--;
        if (timeLeft > 0) {
          closeBtn.textContent = `Wait (${timeLeft})`;
        } else {
          clearInterval(t);
          closeBtn.disabled = false;
          closeBtn.textContent = ''; 
          setRandomCorner(); 
          closeBtn.classList.add('enabled'); 
        }
      }, 1000);
    }

    setTimeout(showAd, showDelay);

    closeBtn.addEventListener('click', () => {
      if (closeBtn.disabled) return;
      adContainer.classList.add('hidden');
      // Set to reappear after 150 seconds
      setTimeout(showAd, reappearDelay);
    });
  })();
</script>

  </body>
</html>

]]></Content>
</Module>